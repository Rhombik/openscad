// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NodeTaskProto.proto

#ifndef PROTOBUF_NodeTaskProto_2eproto__INCLUDED
#define PROTOBUF_NodeTaskProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace NodeTaskProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_NodeTaskProto_2eproto();
void protobuf_AssignDesc_NodeTaskProto_2eproto();
void protobuf_ShutdownFile_NodeTaskProto_2eproto();

class NodeTaskMsg;
class CGALTaskDetails;
class TransformTaskDetails;
class PolySetTaskDetails;
class HullTaskDetails;
class Polyhedron;
class PolySet;
class Polygon;
class Vector;
class Matrix;

enum NodeTaskMsg_NodeTaskType {
  NodeTaskMsg_NodeTaskType_CGALTask = 0,
  NodeTaskMsg_NodeTaskType_TransformTask = 1,
  NodeTaskMsg_NodeTaskType_PolySetTask = 2,
  NodeTaskMsg_NodeTaskType_HullTask = 3
};
bool NodeTaskMsg_NodeTaskType_IsValid(int value);
const NodeTaskMsg_NodeTaskType NodeTaskMsg_NodeTaskType_NodeTaskType_MIN = NodeTaskMsg_NodeTaskType_CGALTask;
const NodeTaskMsg_NodeTaskType NodeTaskMsg_NodeTaskType_NodeTaskType_MAX = NodeTaskMsg_NodeTaskType_HullTask;
const int NodeTaskMsg_NodeTaskType_NodeTaskType_ARRAYSIZE = NodeTaskMsg_NodeTaskType_NodeTaskType_MAX + 1;

enum CGALTaskDetails_OpType {
  CGALTaskDetails_OpType_CGE_UNION = 0,
  CGALTaskDetails_OpType_CGE_INTERSECTION = 1,
  CGALTaskDetails_OpType_CGE_DIFFERENCE = 2,
  CGALTaskDetails_OpType_CGE_MINKOWSKI = 3
};
bool CGALTaskDetails_OpType_IsValid(int value);
const CGALTaskDetails_OpType CGALTaskDetails_OpType_OpType_MIN = CGALTaskDetails_OpType_CGE_UNION;
const CGALTaskDetails_OpType CGALTaskDetails_OpType_OpType_MAX = CGALTaskDetails_OpType_CGE_MINKOWSKI;
const int CGALTaskDetails_OpType_OpType_ARRAYSIZE = CGALTaskDetails_OpType_OpType_MAX + 1;

// ===================================================================

class NodeTaskMsg : public ::google::protobuf::MessageLite {
 public:
  NodeTaskMsg();
  virtual ~NodeTaskMsg();

  NodeTaskMsg(const NodeTaskMsg& from);

  inline NodeTaskMsg& operator=(const NodeTaskMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const NodeTaskMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NodeTaskMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NodeTaskMsg* other);

  // implements Message ----------------------------------------------

  NodeTaskMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NodeTaskMsg& from);
  void MergeFrom(const NodeTaskMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef NodeTaskMsg_NodeTaskType NodeTaskType;
  static const NodeTaskType CGALTask = NodeTaskMsg_NodeTaskType_CGALTask;
  static const NodeTaskType TransformTask = NodeTaskMsg_NodeTaskType_TransformTask;
  static const NodeTaskType PolySetTask = NodeTaskMsg_NodeTaskType_PolySetTask;
  static const NodeTaskType HullTask = NodeTaskMsg_NodeTaskType_HullTask;
  static inline bool NodeTaskType_IsValid(int value) {
    return NodeTaskMsg_NodeTaskType_IsValid(value);
  }
  static const NodeTaskType NodeTaskType_MIN =
    NodeTaskMsg_NodeTaskType_NodeTaskType_MIN;
  static const NodeTaskType NodeTaskType_MAX =
    NodeTaskMsg_NodeTaskType_NodeTaskType_MAX;
  static const int NodeTaskType_ARRAYSIZE =
    NodeTaskMsg_NodeTaskType_NodeTaskType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .NodeTaskProto.NodeTaskMsg.NodeTaskType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NodeTaskProto::NodeTaskMsg_NodeTaskType type() const;
  inline void set_type(::NodeTaskProto::NodeTaskMsg_NodeTaskType value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .NodeTaskProto.CGALTaskDetails cgalTaskDetails = 3;
  inline bool has_cgaltaskdetails() const;
  inline void clear_cgaltaskdetails();
  static const int kCgalTaskDetailsFieldNumber = 3;
  inline const ::NodeTaskProto::CGALTaskDetails& cgaltaskdetails() const;
  inline ::NodeTaskProto::CGALTaskDetails* mutable_cgaltaskdetails();
  inline ::NodeTaskProto::CGALTaskDetails* release_cgaltaskdetails();
  inline void set_allocated_cgaltaskdetails(::NodeTaskProto::CGALTaskDetails* cgaltaskdetails);

  // optional .NodeTaskProto.TransformTaskDetails transformTaskDetails = 4;
  inline bool has_transformtaskdetails() const;
  inline void clear_transformtaskdetails();
  static const int kTransformTaskDetailsFieldNumber = 4;
  inline const ::NodeTaskProto::TransformTaskDetails& transformtaskdetails() const;
  inline ::NodeTaskProto::TransformTaskDetails* mutable_transformtaskdetails();
  inline ::NodeTaskProto::TransformTaskDetails* release_transformtaskdetails();
  inline void set_allocated_transformtaskdetails(::NodeTaskProto::TransformTaskDetails* transformtaskdetails);

  // optional .NodeTaskProto.PolySetTaskDetails polySetTaskDetails = 5;
  inline bool has_polysettaskdetails() const;
  inline void clear_polysettaskdetails();
  static const int kPolySetTaskDetailsFieldNumber = 5;
  inline const ::NodeTaskProto::PolySetTaskDetails& polysettaskdetails() const;
  inline ::NodeTaskProto::PolySetTaskDetails* mutable_polysettaskdetails();
  inline ::NodeTaskProto::PolySetTaskDetails* release_polysettaskdetails();
  inline void set_allocated_polysettaskdetails(::NodeTaskProto::PolySetTaskDetails* polysettaskdetails);

  // optional .NodeTaskProto.HullTaskDetails hullTaskDetails = 6;
  inline bool has_hulltaskdetails() const;
  inline void clear_hulltaskdetails();
  static const int kHullTaskDetailsFieldNumber = 6;
  inline const ::NodeTaskProto::HullTaskDetails& hulltaskdetails() const;
  inline ::NodeTaskProto::HullTaskDetails* mutable_hulltaskdetails();
  inline ::NodeTaskProto::HullTaskDetails* release_hulltaskdetails();
  inline void set_allocated_hulltaskdetails(::NodeTaskProto::HullTaskDetails* hulltaskdetails);

  // @@protoc_insertion_point(class_scope:NodeTaskProto.NodeTaskMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cgaltaskdetails();
  inline void clear_has_cgaltaskdetails();
  inline void set_has_transformtaskdetails();
  inline void clear_has_transformtaskdetails();
  inline void set_has_polysettaskdetails();
  inline void clear_has_polysettaskdetails();
  inline void set_has_hulltaskdetails();
  inline void clear_has_hulltaskdetails();

  int type_;
  ::google::protobuf::uint32 id_;
  ::NodeTaskProto::CGALTaskDetails* cgaltaskdetails_;
  ::NodeTaskProto::TransformTaskDetails* transformtaskdetails_;
  ::NodeTaskProto::PolySetTaskDetails* polysettaskdetails_;
  ::NodeTaskProto::HullTaskDetails* hulltaskdetails_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static NodeTaskMsg* default_instance_;
};
// -------------------------------------------------------------------

class CGALTaskDetails : public ::google::protobuf::MessageLite {
 public:
  CGALTaskDetails();
  virtual ~CGALTaskDetails();

  CGALTaskDetails(const CGALTaskDetails& from);

  inline CGALTaskDetails& operator=(const CGALTaskDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const CGALTaskDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CGALTaskDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CGALTaskDetails* other);

  // implements Message ----------------------------------------------

  CGALTaskDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CGALTaskDetails& from);
  void MergeFrom(const CGALTaskDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CGALTaskDetails_OpType OpType;
  static const OpType CGE_UNION = CGALTaskDetails_OpType_CGE_UNION;
  static const OpType CGE_INTERSECTION = CGALTaskDetails_OpType_CGE_INTERSECTION;
  static const OpType CGE_DIFFERENCE = CGALTaskDetails_OpType_CGE_DIFFERENCE;
  static const OpType CGE_MINKOWSKI = CGALTaskDetails_OpType_CGE_MINKOWSKI;
  static inline bool OpType_IsValid(int value) {
    return CGALTaskDetails_OpType_IsValid(value);
  }
  static const OpType OpType_MIN =
    CGALTaskDetails_OpType_OpType_MIN;
  static const OpType OpType_MAX =
    CGALTaskDetails_OpType_OpType_MAX;
  static const int OpType_ARRAYSIZE =
    CGALTaskDetails_OpType_OpType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .NodeTaskProto.CGALTaskDetails.OpType op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::NodeTaskProto::CGALTaskDetails_OpType op() const;
  inline void set_op(::NodeTaskProto::CGALTaskDetails_OpType value);

  // repeated .NodeTaskProto.Polyhedron polyhedrons = 2;
  inline int polyhedrons_size() const;
  inline void clear_polyhedrons();
  static const int kPolyhedronsFieldNumber = 2;
  inline const ::NodeTaskProto::Polyhedron& polyhedrons(int index) const;
  inline ::NodeTaskProto::Polyhedron* mutable_polyhedrons(int index);
  inline ::NodeTaskProto::Polyhedron* add_polyhedrons();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >&
      polyhedrons() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >*
      mutable_polyhedrons();

  // @@protoc_insertion_point(class_scope:NodeTaskProto.CGALTaskDetails)
 private:
  inline void set_has_op();
  inline void clear_has_op();

  ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron > polyhedrons_;
  int op_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static CGALTaskDetails* default_instance_;
};
// -------------------------------------------------------------------

class TransformTaskDetails : public ::google::protobuf::MessageLite {
 public:
  TransformTaskDetails();
  virtual ~TransformTaskDetails();

  TransformTaskDetails(const TransformTaskDetails& from);

  inline TransformTaskDetails& operator=(const TransformTaskDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransformTaskDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransformTaskDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransformTaskDetails* other);

  // implements Message ----------------------------------------------

  TransformTaskDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransformTaskDetails& from);
  void MergeFrom(const TransformTaskDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NodeTaskProto.Matrix matrix = 1;
  inline bool has_matrix() const;
  inline void clear_matrix();
  static const int kMatrixFieldNumber = 1;
  inline const ::NodeTaskProto::Matrix& matrix() const;
  inline ::NodeTaskProto::Matrix* mutable_matrix();
  inline ::NodeTaskProto::Matrix* release_matrix();
  inline void set_allocated_matrix(::NodeTaskProto::Matrix* matrix);

  // repeated .NodeTaskProto.Polyhedron polyhedrons = 2;
  inline int polyhedrons_size() const;
  inline void clear_polyhedrons();
  static const int kPolyhedronsFieldNumber = 2;
  inline const ::NodeTaskProto::Polyhedron& polyhedrons(int index) const;
  inline ::NodeTaskProto::Polyhedron* mutable_polyhedrons(int index);
  inline ::NodeTaskProto::Polyhedron* add_polyhedrons();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >&
      polyhedrons() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >*
      mutable_polyhedrons();

  // @@protoc_insertion_point(class_scope:NodeTaskProto.TransformTaskDetails)
 private:
  inline void set_has_matrix();
  inline void clear_has_matrix();

  ::NodeTaskProto::Matrix* matrix_;
  ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron > polyhedrons_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static TransformTaskDetails* default_instance_;
};
// -------------------------------------------------------------------

class PolySetTaskDetails : public ::google::protobuf::MessageLite {
 public:
  PolySetTaskDetails();
  virtual ~PolySetTaskDetails();

  PolySetTaskDetails(const PolySetTaskDetails& from);

  inline PolySetTaskDetails& operator=(const PolySetTaskDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const PolySetTaskDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PolySetTaskDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PolySetTaskDetails* other);

  // implements Message ----------------------------------------------

  PolySetTaskDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PolySetTaskDetails& from);
  void MergeFrom(const PolySetTaskDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NodeTaskProto.PolySet polySet = 1;
  inline bool has_polyset() const;
  inline void clear_polyset();
  static const int kPolySetFieldNumber = 1;
  inline const ::NodeTaskProto::PolySet& polyset() const;
  inline ::NodeTaskProto::PolySet* mutable_polyset();
  inline ::NodeTaskProto::PolySet* release_polyset();
  inline void set_allocated_polyset(::NodeTaskProto::PolySet* polyset);

  // @@protoc_insertion_point(class_scope:NodeTaskProto.PolySetTaskDetails)
 private:
  inline void set_has_polyset();
  inline void clear_has_polyset();

  ::NodeTaskProto::PolySet* polyset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static PolySetTaskDetails* default_instance_;
};
// -------------------------------------------------------------------

class HullTaskDetails : public ::google::protobuf::MessageLite {
 public:
  HullTaskDetails();
  virtual ~HullTaskDetails();

  HullTaskDetails(const HullTaskDetails& from);

  inline HullTaskDetails& operator=(const HullTaskDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const HullTaskDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HullTaskDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HullTaskDetails* other);

  // implements Message ----------------------------------------------

  HullTaskDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HullTaskDetails& from);
  void MergeFrom(const HullTaskDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NodeTaskProto.Polyhedron polyhedrons = 1;
  inline int polyhedrons_size() const;
  inline void clear_polyhedrons();
  static const int kPolyhedronsFieldNumber = 1;
  inline const ::NodeTaskProto::Polyhedron& polyhedrons(int index) const;
  inline ::NodeTaskProto::Polyhedron* mutable_polyhedrons(int index);
  inline ::NodeTaskProto::Polyhedron* add_polyhedrons();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >&
      polyhedrons() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >*
      mutable_polyhedrons();

  // @@protoc_insertion_point(class_scope:NodeTaskProto.HullTaskDetails)
 private:

  ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron > polyhedrons_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static HullTaskDetails* default_instance_;
};
// -------------------------------------------------------------------

class Polyhedron : public ::google::protobuf::MessageLite {
 public:
  Polyhedron();
  virtual ~Polyhedron();

  Polyhedron(const Polyhedron& from);

  inline Polyhedron& operator=(const Polyhedron& from) {
    CopyFrom(from);
    return *this;
  }

  static const Polyhedron& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Polyhedron* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Polyhedron* other);

  // implements Message ----------------------------------------------

  Polyhedron* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Polyhedron& from);
  void MergeFrom(const Polyhedron& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is2d = 1;
  inline bool has_is2d() const;
  inline void clear_is2d();
  static const int kIs2DFieldNumber = 1;
  inline bool is2d() const;
  inline void set_is2d(bool value);

  // required string stream = 2;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline const ::std::string& stream() const;
  inline void set_stream(const ::std::string& value);
  inline void set_stream(const char* value);
  inline void set_stream(const char* value, size_t size);
  inline ::std::string* mutable_stream();
  inline ::std::string* release_stream();
  inline void set_allocated_stream(::std::string* stream);

  // @@protoc_insertion_point(class_scope:NodeTaskProto.Polyhedron)
 private:
  inline void set_has_is2d();
  inline void clear_has_is2d();
  inline void set_has_stream();
  inline void clear_has_stream();

  ::std::string* stream_;
  bool is2d_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static Polyhedron* default_instance_;
};
// -------------------------------------------------------------------

class PolySet : public ::google::protobuf::MessageLite {
 public:
  PolySet();
  virtual ~PolySet();

  PolySet(const PolySet& from);

  inline PolySet& operator=(const PolySet& from) {
    CopyFrom(from);
    return *this;
  }

  static const PolySet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PolySet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PolySet* other);

  // implements Message ----------------------------------------------

  PolySet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PolySet& from);
  void MergeFrom(const PolySet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is2d = 1;
  inline bool has_is2d() const;
  inline void clear_is2d();
  static const int kIs2DFieldNumber = 1;
  inline bool is2d() const;
  inline void set_is2d(bool value);

  // required int32 convexivity = 2;
  inline bool has_convexivity() const;
  inline void clear_convexivity();
  static const int kConvexivityFieldNumber = 2;
  inline ::google::protobuf::int32 convexivity() const;
  inline void set_convexivity(::google::protobuf::int32 value);

  // required double resolution = 3;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 3;
  inline double resolution() const;
  inline void set_resolution(double value);

  // repeated .NodeTaskProto.Polygon polygons = 4;
  inline int polygons_size() const;
  inline void clear_polygons();
  static const int kPolygonsFieldNumber = 4;
  inline const ::NodeTaskProto::Polygon& polygons(int index) const;
  inline ::NodeTaskProto::Polygon* mutable_polygons(int index);
  inline ::NodeTaskProto::Polygon* add_polygons();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >&
      polygons() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >*
      mutable_polygons();

  // repeated .NodeTaskProto.Polygon borders = 5;
  inline int borders_size() const;
  inline void clear_borders();
  static const int kBordersFieldNumber = 5;
  inline const ::NodeTaskProto::Polygon& borders(int index) const;
  inline ::NodeTaskProto::Polygon* mutable_borders(int index);
  inline ::NodeTaskProto::Polygon* add_borders();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >&
      borders() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >*
      mutable_borders();

  // @@protoc_insertion_point(class_scope:NodeTaskProto.PolySet)
 private:
  inline void set_has_is2d();
  inline void clear_has_is2d();
  inline void set_has_convexivity();
  inline void clear_has_convexivity();
  inline void set_has_resolution();
  inline void clear_has_resolution();

  bool is2d_;
  ::google::protobuf::int32 convexivity_;
  double resolution_;
  ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon > polygons_;
  ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon > borders_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static PolySet* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::MessageLite {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  static const Polygon& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Polygon* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  Polygon* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NodeTaskProto.Vector vectors = 1;
  inline int vectors_size() const;
  inline void clear_vectors();
  static const int kVectorsFieldNumber = 1;
  inline const ::NodeTaskProto::Vector& vectors(int index) const;
  inline ::NodeTaskProto::Vector* mutable_vectors(int index);
  inline ::NodeTaskProto::Vector* add_vectors();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Vector >&
      vectors() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Vector >*
      mutable_vectors();

  // @@protoc_insertion_point(class_scope:NodeTaskProto.Polygon)
 private:

  ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Vector > vectors_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::MessageLite {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }

  static const Vector& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Vector* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Vector* other);

  // implements Message ----------------------------------------------

  Vector* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline double data(int index) const;
  inline void set_data(int index, double value);
  inline void add_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:NodeTaskProto.Vector)
 private:

  ::google::protobuf::RepeatedField< double > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class Matrix : public ::google::protobuf::MessageLite {
 public:
  Matrix();
  virtual ~Matrix();

  Matrix(const Matrix& from);

  inline Matrix& operator=(const Matrix& from) {
    CopyFrom(from);
    return *this;
  }

  static const Matrix& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Matrix* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Matrix* other);

  // implements Message ----------------------------------------------

  Matrix* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Matrix& from);
  void MergeFrom(const Matrix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rows = 1;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 1;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);

  // required uint32 cols = 2;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 2;
  inline ::google::protobuf::uint32 cols() const;
  inline void set_cols(::google::protobuf::uint32 value);

  // repeated double data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline double data(int index) const;
  inline void set_data(int index, double value);
  inline void add_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:NodeTaskProto.Matrix)
 private:
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_cols();
  inline void clear_has_cols();

  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 cols_;
  ::google::protobuf::RepeatedField< double > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NodeTaskProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_NodeTaskProto_2eproto();
  friend void protobuf_ShutdownFile_NodeTaskProto_2eproto();

  void InitAsDefaultInstance();
  static Matrix* default_instance_;
};
// ===================================================================


// ===================================================================

// NodeTaskMsg

// required .NodeTaskProto.NodeTaskMsg.NodeTaskType type = 1;
inline bool NodeTaskMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeTaskMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeTaskMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeTaskMsg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::NodeTaskProto::NodeTaskMsg_NodeTaskType NodeTaskMsg::type() const {
  return static_cast< ::NodeTaskProto::NodeTaskMsg_NodeTaskType >(type_);
}
inline void NodeTaskMsg::set_type(::NodeTaskProto::NodeTaskMsg_NodeTaskType value) {
  assert(::NodeTaskProto::NodeTaskMsg_NodeTaskType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint32 id = 2;
inline bool NodeTaskMsg::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeTaskMsg::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeTaskMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeTaskMsg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 NodeTaskMsg::id() const {
  return id_;
}
inline void NodeTaskMsg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .NodeTaskProto.CGALTaskDetails cgalTaskDetails = 3;
inline bool NodeTaskMsg::has_cgaltaskdetails() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeTaskMsg::set_has_cgaltaskdetails() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeTaskMsg::clear_has_cgaltaskdetails() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeTaskMsg::clear_cgaltaskdetails() {
  if (cgaltaskdetails_ != NULL) cgaltaskdetails_->::NodeTaskProto::CGALTaskDetails::Clear();
  clear_has_cgaltaskdetails();
}
inline const ::NodeTaskProto::CGALTaskDetails& NodeTaskMsg::cgaltaskdetails() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cgaltaskdetails_ != NULL ? *cgaltaskdetails_ : *default_instance().cgaltaskdetails_;
#else
  return cgaltaskdetails_ != NULL ? *cgaltaskdetails_ : *default_instance_->cgaltaskdetails_;
#endif
}
inline ::NodeTaskProto::CGALTaskDetails* NodeTaskMsg::mutable_cgaltaskdetails() {
  set_has_cgaltaskdetails();
  if (cgaltaskdetails_ == NULL) cgaltaskdetails_ = new ::NodeTaskProto::CGALTaskDetails;
  return cgaltaskdetails_;
}
inline ::NodeTaskProto::CGALTaskDetails* NodeTaskMsg::release_cgaltaskdetails() {
  clear_has_cgaltaskdetails();
  ::NodeTaskProto::CGALTaskDetails* temp = cgaltaskdetails_;
  cgaltaskdetails_ = NULL;
  return temp;
}
inline void NodeTaskMsg::set_allocated_cgaltaskdetails(::NodeTaskProto::CGALTaskDetails* cgaltaskdetails) {
  delete cgaltaskdetails_;
  cgaltaskdetails_ = cgaltaskdetails;
  if (cgaltaskdetails) {
    set_has_cgaltaskdetails();
  } else {
    clear_has_cgaltaskdetails();
  }
}

// optional .NodeTaskProto.TransformTaskDetails transformTaskDetails = 4;
inline bool NodeTaskMsg::has_transformtaskdetails() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeTaskMsg::set_has_transformtaskdetails() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeTaskMsg::clear_has_transformtaskdetails() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeTaskMsg::clear_transformtaskdetails() {
  if (transformtaskdetails_ != NULL) transformtaskdetails_->::NodeTaskProto::TransformTaskDetails::Clear();
  clear_has_transformtaskdetails();
}
inline const ::NodeTaskProto::TransformTaskDetails& NodeTaskMsg::transformtaskdetails() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transformtaskdetails_ != NULL ? *transformtaskdetails_ : *default_instance().transformtaskdetails_;
#else
  return transformtaskdetails_ != NULL ? *transformtaskdetails_ : *default_instance_->transformtaskdetails_;
#endif
}
inline ::NodeTaskProto::TransformTaskDetails* NodeTaskMsg::mutable_transformtaskdetails() {
  set_has_transformtaskdetails();
  if (transformtaskdetails_ == NULL) transformtaskdetails_ = new ::NodeTaskProto::TransformTaskDetails;
  return transformtaskdetails_;
}
inline ::NodeTaskProto::TransformTaskDetails* NodeTaskMsg::release_transformtaskdetails() {
  clear_has_transformtaskdetails();
  ::NodeTaskProto::TransformTaskDetails* temp = transformtaskdetails_;
  transformtaskdetails_ = NULL;
  return temp;
}
inline void NodeTaskMsg::set_allocated_transformtaskdetails(::NodeTaskProto::TransformTaskDetails* transformtaskdetails) {
  delete transformtaskdetails_;
  transformtaskdetails_ = transformtaskdetails;
  if (transformtaskdetails) {
    set_has_transformtaskdetails();
  } else {
    clear_has_transformtaskdetails();
  }
}

// optional .NodeTaskProto.PolySetTaskDetails polySetTaskDetails = 5;
inline bool NodeTaskMsg::has_polysettaskdetails() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeTaskMsg::set_has_polysettaskdetails() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeTaskMsg::clear_has_polysettaskdetails() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeTaskMsg::clear_polysettaskdetails() {
  if (polysettaskdetails_ != NULL) polysettaskdetails_->::NodeTaskProto::PolySetTaskDetails::Clear();
  clear_has_polysettaskdetails();
}
inline const ::NodeTaskProto::PolySetTaskDetails& NodeTaskMsg::polysettaskdetails() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return polysettaskdetails_ != NULL ? *polysettaskdetails_ : *default_instance().polysettaskdetails_;
#else
  return polysettaskdetails_ != NULL ? *polysettaskdetails_ : *default_instance_->polysettaskdetails_;
#endif
}
inline ::NodeTaskProto::PolySetTaskDetails* NodeTaskMsg::mutable_polysettaskdetails() {
  set_has_polysettaskdetails();
  if (polysettaskdetails_ == NULL) polysettaskdetails_ = new ::NodeTaskProto::PolySetTaskDetails;
  return polysettaskdetails_;
}
inline ::NodeTaskProto::PolySetTaskDetails* NodeTaskMsg::release_polysettaskdetails() {
  clear_has_polysettaskdetails();
  ::NodeTaskProto::PolySetTaskDetails* temp = polysettaskdetails_;
  polysettaskdetails_ = NULL;
  return temp;
}
inline void NodeTaskMsg::set_allocated_polysettaskdetails(::NodeTaskProto::PolySetTaskDetails* polysettaskdetails) {
  delete polysettaskdetails_;
  polysettaskdetails_ = polysettaskdetails;
  if (polysettaskdetails) {
    set_has_polysettaskdetails();
  } else {
    clear_has_polysettaskdetails();
  }
}

// optional .NodeTaskProto.HullTaskDetails hullTaskDetails = 6;
inline bool NodeTaskMsg::has_hulltaskdetails() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeTaskMsg::set_has_hulltaskdetails() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeTaskMsg::clear_has_hulltaskdetails() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeTaskMsg::clear_hulltaskdetails() {
  if (hulltaskdetails_ != NULL) hulltaskdetails_->::NodeTaskProto::HullTaskDetails::Clear();
  clear_has_hulltaskdetails();
}
inline const ::NodeTaskProto::HullTaskDetails& NodeTaskMsg::hulltaskdetails() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hulltaskdetails_ != NULL ? *hulltaskdetails_ : *default_instance().hulltaskdetails_;
#else
  return hulltaskdetails_ != NULL ? *hulltaskdetails_ : *default_instance_->hulltaskdetails_;
#endif
}
inline ::NodeTaskProto::HullTaskDetails* NodeTaskMsg::mutable_hulltaskdetails() {
  set_has_hulltaskdetails();
  if (hulltaskdetails_ == NULL) hulltaskdetails_ = new ::NodeTaskProto::HullTaskDetails;
  return hulltaskdetails_;
}
inline ::NodeTaskProto::HullTaskDetails* NodeTaskMsg::release_hulltaskdetails() {
  clear_has_hulltaskdetails();
  ::NodeTaskProto::HullTaskDetails* temp = hulltaskdetails_;
  hulltaskdetails_ = NULL;
  return temp;
}
inline void NodeTaskMsg::set_allocated_hulltaskdetails(::NodeTaskProto::HullTaskDetails* hulltaskdetails) {
  delete hulltaskdetails_;
  hulltaskdetails_ = hulltaskdetails;
  if (hulltaskdetails) {
    set_has_hulltaskdetails();
  } else {
    clear_has_hulltaskdetails();
  }
}

// -------------------------------------------------------------------

// CGALTaskDetails

// required .NodeTaskProto.CGALTaskDetails.OpType op = 1;
inline bool CGALTaskDetails::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGALTaskDetails::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGALTaskDetails::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGALTaskDetails::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline ::NodeTaskProto::CGALTaskDetails_OpType CGALTaskDetails::op() const {
  return static_cast< ::NodeTaskProto::CGALTaskDetails_OpType >(op_);
}
inline void CGALTaskDetails::set_op(::NodeTaskProto::CGALTaskDetails_OpType value) {
  assert(::NodeTaskProto::CGALTaskDetails_OpType_IsValid(value));
  set_has_op();
  op_ = value;
}

// repeated .NodeTaskProto.Polyhedron polyhedrons = 2;
inline int CGALTaskDetails::polyhedrons_size() const {
  return polyhedrons_.size();
}
inline void CGALTaskDetails::clear_polyhedrons() {
  polyhedrons_.Clear();
}
inline const ::NodeTaskProto::Polyhedron& CGALTaskDetails::polyhedrons(int index) const {
  return polyhedrons_.Get(index);
}
inline ::NodeTaskProto::Polyhedron* CGALTaskDetails::mutable_polyhedrons(int index) {
  return polyhedrons_.Mutable(index);
}
inline ::NodeTaskProto::Polyhedron* CGALTaskDetails::add_polyhedrons() {
  return polyhedrons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >&
CGALTaskDetails::polyhedrons() const {
  return polyhedrons_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >*
CGALTaskDetails::mutable_polyhedrons() {
  return &polyhedrons_;
}

// -------------------------------------------------------------------

// TransformTaskDetails

// required .NodeTaskProto.Matrix matrix = 1;
inline bool TransformTaskDetails::has_matrix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformTaskDetails::set_has_matrix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformTaskDetails::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformTaskDetails::clear_matrix() {
  if (matrix_ != NULL) matrix_->::NodeTaskProto::Matrix::Clear();
  clear_has_matrix();
}
inline const ::NodeTaskProto::Matrix& TransformTaskDetails::matrix() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matrix_ != NULL ? *matrix_ : *default_instance().matrix_;
#else
  return matrix_ != NULL ? *matrix_ : *default_instance_->matrix_;
#endif
}
inline ::NodeTaskProto::Matrix* TransformTaskDetails::mutable_matrix() {
  set_has_matrix();
  if (matrix_ == NULL) matrix_ = new ::NodeTaskProto::Matrix;
  return matrix_;
}
inline ::NodeTaskProto::Matrix* TransformTaskDetails::release_matrix() {
  clear_has_matrix();
  ::NodeTaskProto::Matrix* temp = matrix_;
  matrix_ = NULL;
  return temp;
}
inline void TransformTaskDetails::set_allocated_matrix(::NodeTaskProto::Matrix* matrix) {
  delete matrix_;
  matrix_ = matrix;
  if (matrix) {
    set_has_matrix();
  } else {
    clear_has_matrix();
  }
}

// repeated .NodeTaskProto.Polyhedron polyhedrons = 2;
inline int TransformTaskDetails::polyhedrons_size() const {
  return polyhedrons_.size();
}
inline void TransformTaskDetails::clear_polyhedrons() {
  polyhedrons_.Clear();
}
inline const ::NodeTaskProto::Polyhedron& TransformTaskDetails::polyhedrons(int index) const {
  return polyhedrons_.Get(index);
}
inline ::NodeTaskProto::Polyhedron* TransformTaskDetails::mutable_polyhedrons(int index) {
  return polyhedrons_.Mutable(index);
}
inline ::NodeTaskProto::Polyhedron* TransformTaskDetails::add_polyhedrons() {
  return polyhedrons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >&
TransformTaskDetails::polyhedrons() const {
  return polyhedrons_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >*
TransformTaskDetails::mutable_polyhedrons() {
  return &polyhedrons_;
}

// -------------------------------------------------------------------

// PolySetTaskDetails

// required .NodeTaskProto.PolySet polySet = 1;
inline bool PolySetTaskDetails::has_polyset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolySetTaskDetails::set_has_polyset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PolySetTaskDetails::clear_has_polyset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PolySetTaskDetails::clear_polyset() {
  if (polyset_ != NULL) polyset_->::NodeTaskProto::PolySet::Clear();
  clear_has_polyset();
}
inline const ::NodeTaskProto::PolySet& PolySetTaskDetails::polyset() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return polyset_ != NULL ? *polyset_ : *default_instance().polyset_;
#else
  return polyset_ != NULL ? *polyset_ : *default_instance_->polyset_;
#endif
}
inline ::NodeTaskProto::PolySet* PolySetTaskDetails::mutable_polyset() {
  set_has_polyset();
  if (polyset_ == NULL) polyset_ = new ::NodeTaskProto::PolySet;
  return polyset_;
}
inline ::NodeTaskProto::PolySet* PolySetTaskDetails::release_polyset() {
  clear_has_polyset();
  ::NodeTaskProto::PolySet* temp = polyset_;
  polyset_ = NULL;
  return temp;
}
inline void PolySetTaskDetails::set_allocated_polyset(::NodeTaskProto::PolySet* polyset) {
  delete polyset_;
  polyset_ = polyset;
  if (polyset) {
    set_has_polyset();
  } else {
    clear_has_polyset();
  }
}

// -------------------------------------------------------------------

// HullTaskDetails

// repeated .NodeTaskProto.Polyhedron polyhedrons = 1;
inline int HullTaskDetails::polyhedrons_size() const {
  return polyhedrons_.size();
}
inline void HullTaskDetails::clear_polyhedrons() {
  polyhedrons_.Clear();
}
inline const ::NodeTaskProto::Polyhedron& HullTaskDetails::polyhedrons(int index) const {
  return polyhedrons_.Get(index);
}
inline ::NodeTaskProto::Polyhedron* HullTaskDetails::mutable_polyhedrons(int index) {
  return polyhedrons_.Mutable(index);
}
inline ::NodeTaskProto::Polyhedron* HullTaskDetails::add_polyhedrons() {
  return polyhedrons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >&
HullTaskDetails::polyhedrons() const {
  return polyhedrons_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polyhedron >*
HullTaskDetails::mutable_polyhedrons() {
  return &polyhedrons_;
}

// -------------------------------------------------------------------

// Polyhedron

// required bool is2d = 1;
inline bool Polyhedron::has_is2d() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Polyhedron::set_has_is2d() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Polyhedron::clear_has_is2d() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Polyhedron::clear_is2d() {
  is2d_ = false;
  clear_has_is2d();
}
inline bool Polyhedron::is2d() const {
  return is2d_;
}
inline void Polyhedron::set_is2d(bool value) {
  set_has_is2d();
  is2d_ = value;
}

// required string stream = 2;
inline bool Polyhedron::has_stream() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Polyhedron::set_has_stream() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Polyhedron::clear_has_stream() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Polyhedron::clear_stream() {
  if (stream_ != &::google::protobuf::internal::kEmptyString) {
    stream_->clear();
  }
  clear_has_stream();
}
inline const ::std::string& Polyhedron::stream() const {
  return *stream_;
}
inline void Polyhedron::set_stream(const ::std::string& value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void Polyhedron::set_stream(const char* value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void Polyhedron::set_stream(const char* value, size_t size) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Polyhedron::mutable_stream() {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  return stream_;
}
inline ::std::string* Polyhedron::release_stream() {
  clear_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_;
    stream_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Polyhedron::set_allocated_stream(::std::string* stream) {
  if (stream_ != &::google::protobuf::internal::kEmptyString) {
    delete stream_;
  }
  if (stream) {
    set_has_stream();
    stream_ = stream;
  } else {
    clear_has_stream();
    stream_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PolySet

// required bool is2d = 1;
inline bool PolySet::has_is2d() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolySet::set_has_is2d() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PolySet::clear_has_is2d() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PolySet::clear_is2d() {
  is2d_ = false;
  clear_has_is2d();
}
inline bool PolySet::is2d() const {
  return is2d_;
}
inline void PolySet::set_is2d(bool value) {
  set_has_is2d();
  is2d_ = value;
}

// required int32 convexivity = 2;
inline bool PolySet::has_convexivity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolySet::set_has_convexivity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PolySet::clear_has_convexivity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PolySet::clear_convexivity() {
  convexivity_ = 0;
  clear_has_convexivity();
}
inline ::google::protobuf::int32 PolySet::convexivity() const {
  return convexivity_;
}
inline void PolySet::set_convexivity(::google::protobuf::int32 value) {
  set_has_convexivity();
  convexivity_ = value;
}

// required double resolution = 3;
inline bool PolySet::has_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolySet::set_has_resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PolySet::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PolySet::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline double PolySet::resolution() const {
  return resolution_;
}
inline void PolySet::set_resolution(double value) {
  set_has_resolution();
  resolution_ = value;
}

// repeated .NodeTaskProto.Polygon polygons = 4;
inline int PolySet::polygons_size() const {
  return polygons_.size();
}
inline void PolySet::clear_polygons() {
  polygons_.Clear();
}
inline const ::NodeTaskProto::Polygon& PolySet::polygons(int index) const {
  return polygons_.Get(index);
}
inline ::NodeTaskProto::Polygon* PolySet::mutable_polygons(int index) {
  return polygons_.Mutable(index);
}
inline ::NodeTaskProto::Polygon* PolySet::add_polygons() {
  return polygons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >&
PolySet::polygons() const {
  return polygons_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >*
PolySet::mutable_polygons() {
  return &polygons_;
}

// repeated .NodeTaskProto.Polygon borders = 5;
inline int PolySet::borders_size() const {
  return borders_.size();
}
inline void PolySet::clear_borders() {
  borders_.Clear();
}
inline const ::NodeTaskProto::Polygon& PolySet::borders(int index) const {
  return borders_.Get(index);
}
inline ::NodeTaskProto::Polygon* PolySet::mutable_borders(int index) {
  return borders_.Mutable(index);
}
inline ::NodeTaskProto::Polygon* PolySet::add_borders() {
  return borders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >&
PolySet::borders() const {
  return borders_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Polygon >*
PolySet::mutable_borders() {
  return &borders_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .NodeTaskProto.Vector vectors = 1;
inline int Polygon::vectors_size() const {
  return vectors_.size();
}
inline void Polygon::clear_vectors() {
  vectors_.Clear();
}
inline const ::NodeTaskProto::Vector& Polygon::vectors(int index) const {
  return vectors_.Get(index);
}
inline ::NodeTaskProto::Vector* Polygon::mutable_vectors(int index) {
  return vectors_.Mutable(index);
}
inline ::NodeTaskProto::Vector* Polygon::add_vectors() {
  return vectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Vector >&
Polygon::vectors() const {
  return vectors_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeTaskProto::Vector >*
Polygon::mutable_vectors() {
  return &vectors_;
}

// -------------------------------------------------------------------

// Vector

// repeated double data = 1;
inline int Vector::data_size() const {
  return data_.size();
}
inline void Vector::clear_data() {
  data_.Clear();
}
inline double Vector::data(int index) const {
  return data_.Get(index);
}
inline void Vector::set_data(int index, double value) {
  data_.Set(index, value);
}
inline void Vector::add_data(double value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Vector::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
Vector::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// Matrix

// required uint32 rows = 1;
inline bool Matrix::has_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Matrix::set_has_rows() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Matrix::clear_has_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Matrix::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 Matrix::rows() const {
  return rows_;
}
inline void Matrix::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
}

// required uint32 cols = 2;
inline bool Matrix::has_cols() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Matrix::set_has_cols() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Matrix::clear_has_cols() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Matrix::clear_cols() {
  cols_ = 0u;
  clear_has_cols();
}
inline ::google::protobuf::uint32 Matrix::cols() const {
  return cols_;
}
inline void Matrix::set_cols(::google::protobuf::uint32 value) {
  set_has_cols();
  cols_ = value;
}

// repeated double data = 3;
inline int Matrix::data_size() const {
  return data_.size();
}
inline void Matrix::clear_data() {
  data_.Clear();
}
inline double Matrix::data(int index) const {
  return data_.Get(index);
}
inline void Matrix::set_data(int index, double value) {
  data_.Set(index, value);
}
inline void Matrix::add_data(double value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Matrix::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
Matrix::mutable_data() {
  return &data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NodeTaskProto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NodeTaskProto_2eproto__INCLUDED
